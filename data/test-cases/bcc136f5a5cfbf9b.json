{"uid":"bcc136f5a5cfbf9b","name":"Calculation Testing | Scenario=S9 | Mode=Debit Card | Slab=1001-5000 | Amount=1200","fullName":"testCases.Calculation_test.TestCalculations#test_calculation_amount","historyId":"3222f21814d7fd6c1366eebb310dbc33","time":{"start":1758690944823,"stop":1758690968813,"duration":23990},"description":"Test the cancel transaction button functionality.","descriptionHtml":"<p>Test the cancel transaction button functionality.</p>\n","status":"broken","statusMessage":"PermissionError: [Errno 13] Permission denied: 'TestData/Calculation_Testing_Report.xlsx'","statusTrace":"self = <testCases.Calculation_test.TestCalculations object at 0x000001AA353E7C50>, page_with_screenshot = <Page url='https://stage-securepay.sabpaisa.in/SabPaisa/sabPaisaInit?v=1'>\nscenario = 'S9', payment_mode = 'Debit Card', slab = '1001-5000', amount = 1200, excel_client_code = 'TM001', excel_environment = 'STAGING', ensure_db_updated = None\n\n    @allure.story(\"Cancel Transaction Button Check\")\n    @allure.severity(allure.severity_level.CRITICAL)\n    @pytest.mark.ui\n    @pytest.mark.regression\n    def test_calculation_amount(self, page_with_screenshot, scenario, payment_mode, slab, amount, excel_client_code,\n                                excel_environment, ensure_db_updated):\n        \"\"\"Test the cancel transaction button functionality.\"\"\"\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        allure.dynamic.title(\n            f\"Calculation Testing | Scenario={scenario} | Mode={payment_mode} | Slab={slab} | Amount={amount}\"\n        )\n        self.logger.info(f\"--- Starting calculation Test for {scenario} | {payment_mode} | {slab} | {amount} ---\")\n    \n        bill_amount = conv_charges = total_amount = txn_id = \"N/A\"\n        status = \"Fail\"\n    \n        try:\n            if payment_mode == \"UPI INTENT\":\n                viewport_size = {\"width\": 375, \"height\": 667}  # Example: iPhone-like dimensions\n                page_with_screenshot.set_viewport_size(viewport_size)\n                self.logger.info(\n                    f\"Set viewport size to {viewport_size['width']}x{viewport_size['height']} for UPI INTENT mode\")\n                allure.attach(page_with_screenshot.screenshot(), name=\"UPI Intent Initial Viewport\",\n                              attachment_type=allure.attachment_type.PNG)\n    \n    \n            # Initialize page objects\n            client = ClientPage(page_with_screenshot)\n            client_details = ClientDetailsPage(page_with_screenshot)\n            pg = PaymentGatewayPage(page_with_screenshot)\n            pg_response = PaymentGatewayResponsePage(page_with_screenshot)\n    \n            # Fill and verify client and payer details\n            fill_and_verify_client_details(self.logger, client, client_details, excel_client_code, excel_environment)\n            fill_payer_details(\n                self.logger, client_details, ReadConfig.get_payer_first_name(),\n                ReadConfig.get_payer_last_name(), str(amount), ReadConfig.get_payer_phone(),\n                ReadConfig.get_payer_email()\n            )\n    \n            # Get transaction ID\n            with allure.step(f\"Accessing the Client_txn_id\"):\n                txn_id = client_details.get_value(\"_client_transaction_id\")\n                allure.attach(txn_id, name=f\"Client Transaction ID for {excel_client_code}\",\n                              attachment_type=allure.attachment_type.TEXT)\n    \n            # Click Pay button\n            with allure.step(\"Clicking Pay Button\"):\n                self.logger.info(\"Clicking Pay button\")\n                client_details.click(\"_pay_btn\")\n    \n            time.sleep(5)\n    \n            # Handle payment mode and get amounts\n            bill_amount, conv_charges, total_amount = self._handle_payment_mode(pg, payment_mode, self.logger)\n    \n    \n            time.sleep(10)\n    \n    \n    \n            # # Wait for page to load and validate URL\n            # time.sleep(5)\n            # pg_response.page.wait_for_load_state(\"networkidle\")\n            # current_url = pg_response.get_current_url()\n            # self.logger.info(f\"URL after proceed to pay: {current_url}\")\n            #\n            # with allure.step(\"Validating the Base URL\"):\n            #     assert validate_base_url(current_url,\n            #                              excel_environment), f\"Base URL validation failed for {current_url}\"\n    \n            status = \"Pass\"\n    \n        except Exception as e:\n            self.logger.exception(\n                f\"Exception occurred during Cancel Transaction Test for {excel_client_code}: {str(e)}\")\n            allure.attach(str(e), name=\"Exception Details\", attachment_type=allure.attachment_type.TEXT)\n            raise\n    \n        finally:\n            # Update Excel with results\n>           update_excel_results(\n                scenario=scenario,\n                payment_mode=payment_mode,\n                slab=slab,\n                request_amount=amount,\n                actual_bill=bill_amount,\n                conv_charges=conv_charges,\n                total_amount=total_amount,\n                status=status,\n                txn_id=txn_id\n            )\n\ntestCases\\Calculation_test.py:222: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nutilites\\calculation_excel_helper.py:44: in update_excel_results\n    df.to_excel(file_path, index=False)\n.venv\\Lib\\site-packages\\pandas\\util\\_decorators.py:333: in wrapper\n    return func(*args, **kwargs)\n.venv\\Lib\\site-packages\\pandas\\core\\generic.py:2436: in to_excel\n    formatter.write(\n.venv\\Lib\\site-packages\\pandas\\io\\formats\\excel.py:943: in write\n    writer = ExcelWriter(\n.venv\\Lib\\site-packages\\pandas\\io\\excel\\_openpyxl.py:61: in __init__\n    super().__init__(\n.venv\\Lib\\site-packages\\pandas\\io\\excel\\_base.py:1246: in __init__\n    self._handles = get_handle(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npath_or_buf = 'TestData/Calculation_Testing_Report.xlsx', mode = 'wb'\n\n    @doc(compression_options=_shared_docs[\"compression_options\"] % \"path_or_buf\")\n    def get_handle(\n        path_or_buf: FilePath | BaseBuffer,\n        mode: str,\n        *,\n        encoding: str | None = None,\n        compression: CompressionOptions | None = None,\n        memory_map: bool = False,\n        is_text: bool = True,\n        errors: str | None = None,\n        storage_options: StorageOptions | None = None,\n    ) -> IOHandles[str] | IOHandles[bytes]:\n        \"\"\"\n        Get file handle for given path/buffer and mode.\n    \n        Parameters\n        ----------\n        path_or_buf : str or file handle\n            File path or object.\n        mode : str\n            Mode to open path_or_buf with.\n        encoding : str or None\n            Encoding to use.\n        {compression_options}\n    \n               May be a dict with key 'method' as compression mode\n               and other keys as compression options if compression\n               mode is 'zip'.\n    \n               Passing compression options as keys in dict is\n               supported for compression modes 'gzip', 'bz2', 'zstd' and 'zip'.\n    \n            .. versionchanged:: 1.4.0 Zstandard support.\n    \n        memory_map : bool, default False\n            See parsers._parser_params for more information. Only used by read_csv.\n        is_text : bool, default True\n            Whether the type of the content passed to the file/buffer is string or\n            bytes. This is not the same as `\"b\" not in mode`. If a string content is\n            passed to a binary file/buffer, a wrapper is inserted.\n        errors : str, default 'strict'\n            Specifies how encoding and decoding errors are to be handled.\n            See the errors argument for :func:`open` for a full list\n            of options.\n        storage_options: StorageOptions = None\n            Passed to _get_filepath_or_buffer\n    \n        Returns the dataclass IOHandles\n        \"\"\"\n        # Windows does not default to utf-8. Set to utf-8 for a consistent behavior\n        encoding = encoding or \"utf-8\"\n    \n        errors = errors or \"strict\"\n    \n        # read_csv does not know whether the buffer is opened in binary/text mode\n        if _is_binary_mode(path_or_buf, mode) and \"b\" not in mode:\n            mode += \"b\"\n    \n        # validate encoding and errors\n        codecs.lookup(encoding)\n        if isinstance(errors, str):\n            codecs.lookup_error(errors)\n    \n        # open URLs\n        ioargs = _get_filepath_or_buffer(\n            path_or_buf,\n            encoding=encoding,\n            compression=compression,\n            mode=mode,\n            storage_options=storage_options,\n        )\n    \n        handle = ioargs.filepath_or_buffer\n        handles: list[BaseBuffer]\n    \n        # memory mapping needs to be the first step\n        # only used for read_csv\n        handle, memory_map, handles = _maybe_memory_map(handle, memory_map)\n    \n        is_path = isinstance(handle, str)\n        compression_args = dict(ioargs.compression)\n        compression = compression_args.pop(\"method\")\n    \n        # Only for write methods\n        if \"r\" not in mode and is_path:\n            check_parent_directory(str(handle))\n    \n        if compression:\n            if compression != \"zstd\":\n                # compression libraries do not like an explicit text-mode\n                ioargs.mode = ioargs.mode.replace(\"t\", \"\")\n            elif compression == \"zstd\" and \"b\" not in ioargs.mode:\n                # python-zstandard defaults to text mode, but we always expect\n                # compression libraries to use binary mode.\n                ioargs.mode += \"b\"\n    \n            # GZ Compression\n            if compression == \"gzip\":\n                if isinstance(handle, str):\n                    # error: Incompatible types in assignment (expression has type\n                    # \"GzipFile\", variable has type \"Union[str, BaseBuffer]\")\n                    handle = gzip.GzipFile(  # type: ignore[assignment]\n                        filename=handle,\n                        mode=ioargs.mode,\n                        **compression_args,\n                    )\n                else:\n                    handle = gzip.GzipFile(\n                        # No overload variant of \"GzipFile\" matches argument types\n                        # \"Union[str, BaseBuffer]\", \"str\", \"Dict[str, Any]\"\n                        fileobj=handle,  # type: ignore[call-overload]\n                        mode=ioargs.mode,\n                        **compression_args,\n                    )\n    \n            # BZ Compression\n            elif compression == \"bz2\":\n                # Overload of \"BZ2File\" to handle pickle protocol 5\n                # \"Union[str, BaseBuffer]\", \"str\", \"Dict[str, Any]\"\n                handle = get_bz2_file()(  # type: ignore[call-overload]\n                    handle,\n                    mode=ioargs.mode,\n                    **compression_args,\n                )\n    \n            # ZIP Compression\n            elif compression == \"zip\":\n                # error: Argument 1 to \"_BytesZipFile\" has incompatible type\n                # \"Union[str, BaseBuffer]\"; expected \"Union[Union[str, PathLike[str]],\n                # ReadBuffer[bytes], WriteBuffer[bytes]]\"\n                handle = _BytesZipFile(\n                    handle, ioargs.mode, **compression_args  # type: ignore[arg-type]\n                )\n                if handle.buffer.mode == \"r\":\n                    handles.append(handle)\n                    zip_names = handle.buffer.namelist()\n                    if len(zip_names) == 1:\n                        handle = handle.buffer.open(zip_names.pop())\n                    elif not zip_names:\n                        raise ValueError(f\"Zero files found in ZIP file {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in ZIP file. \"\n                            f\"Only one file per ZIP: {zip_names}\"\n                        )\n    \n            # TAR Encoding\n            elif compression == \"tar\":\n                compression_args.setdefault(\"mode\", ioargs.mode)\n                if isinstance(handle, str):\n                    handle = _BytesTarFile(name=handle, **compression_args)\n                else:\n                    # error: Argument \"fileobj\" to \"_BytesTarFile\" has incompatible\n                    # type \"BaseBuffer\"; expected \"Union[ReadBuffer[bytes],\n                    # WriteBuffer[bytes], None]\"\n                    handle = _BytesTarFile(\n                        fileobj=handle, **compression_args  # type: ignore[arg-type]\n                    )\n                assert isinstance(handle, _BytesTarFile)\n                if \"r\" in handle.buffer.mode:\n                    handles.append(handle)\n                    files = handle.buffer.getnames()\n                    if len(files) == 1:\n                        file = handle.buffer.extractfile(files[0])\n                        assert file is not None\n                        handle = file\n                    elif not files:\n                        raise ValueError(f\"Zero files found in TAR archive {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in TAR archive. \"\n                            f\"Only one file per TAR archive: {files}\"\n                        )\n    \n            # XZ Compression\n            elif compression == \"xz\":\n                # error: Argument 1 to \"LZMAFile\" has incompatible type \"Union[str,\n                # BaseBuffer]\"; expected \"Optional[Union[Union[str, bytes, PathLike[str],\n                # PathLike[bytes]], IO[bytes]], None]\"\n                handle = get_lzma_file()(\n                    handle, ioargs.mode, **compression_args  # type: ignore[arg-type]\n                )\n    \n            # Zstd Compression\n            elif compression == \"zstd\":\n                zstd = import_optional_dependency(\"zstandard\")\n                if \"r\" in ioargs.mode:\n                    open_args = {\"dctx\": zstd.ZstdDecompressor(**compression_args)}\n                else:\n                    open_args = {\"cctx\": zstd.ZstdCompressor(**compression_args)}\n                handle = zstd.open(\n                    handle,\n                    mode=ioargs.mode,\n                    **open_args,\n                )\n    \n            # Unrecognized Compression\n            else:\n                msg = f\"Unrecognized compression type: {compression}\"\n                raise ValueError(msg)\n    \n            assert not isinstance(handle, str)\n            handles.append(handle)\n    \n        elif isinstance(handle, str):\n            # Check whether the filename is to be opened in binary mode.\n            # Binary mode does not support 'encoding' and 'newline'.\n            if ioargs.encoding and \"b\" not in ioargs.mode:\n                # Encoding\n                handle = open(\n                    handle,\n                    ioargs.mode,\n                    encoding=ioargs.encoding,\n                    errors=errors,\n                    newline=\"\",\n                )\n            else:\n                # Binary mode\n>               handle = open(handle, ioargs.mode)\nE               PermissionError: [Errno 13] Permission denied: 'TestData/Calculation_Testing_Report.xlsx'\n\n.venv\\Lib\\site-packages\\pandas\\io\\common.py:882: PermissionError","flaky":false,"newFailed":false,"newBroken":false,"newPassed":false,"retriesCount":1,"retriesStatusChange":true,"beforeStages":[{"name":"attach_test_timestamp","time":{"start":1758690939264,"stop":1758690939267,"duration":3},"status":"passed","steps":[],"attachments":[{"uid":"62816f58d1e5c46c","name":"Test Execution Timestamp","source":"62816f58d1e5c46c.txt","type":"text/plain","size":19}],"parameters":[],"shouldDisplayMessage":false,"attachmentsCount":1,"attachmentStep":false,"hasContent":true,"stepsCount":0},{"name":"browser","time":{"start":1758690939267,"stop":1758690941173,"duration":1906},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"attachmentsCount":0,"attachmentStep":false,"hasContent":false,"stepsCount":0},{"name":"page","time":{"start":1758690941173,"stop":1758690944811,"duration":3638},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"attachmentsCount":0,"attachmentStep":false,"hasContent":false,"stepsCount":0},{"name":"page_with_screenshot","time":{"start":1758690944811,"stop":1758690944811,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"attachmentsCount":0,"attachmentStep":false,"hasContent":false,"stepsCount":0},{"name":"ensure_db_updated","time":{"start":1758690944812,"stop":1758690944821,"duration":9},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"attachmentsCount":0,"attachmentStep":false,"hasContent":false,"stepsCount":0}],"testStage":{"description":"Test the cancel transaction button functionality.","status":"broken","statusMessage":"PermissionError: [Errno 13] Permission denied: 'TestData/Calculation_Testing_Report.xlsx'","statusTrace":"self = <testCases.Calculation_test.TestCalculations object at 0x000001AA353E7C50>, page_with_screenshot = <Page url='https://stage-securepay.sabpaisa.in/SabPaisa/sabPaisaInit?v=1'>\nscenario = 'S9', payment_mode = 'Debit Card', slab = '1001-5000', amount = 1200, excel_client_code = 'TM001', excel_environment = 'STAGING', ensure_db_updated = None\n\n    @allure.story(\"Cancel Transaction Button Check\")\n    @allure.severity(allure.severity_level.CRITICAL)\n    @pytest.mark.ui\n    @pytest.mark.regression\n    def test_calculation_amount(self, page_with_screenshot, scenario, payment_mode, slab, amount, excel_client_code,\n                                excel_environment, ensure_db_updated):\n        \"\"\"Test the cancel transaction button functionality.\"\"\"\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        allure.dynamic.title(\n            f\"Calculation Testing | Scenario={scenario} | Mode={payment_mode} | Slab={slab} | Amount={amount}\"\n        )\n        self.logger.info(f\"--- Starting calculation Test for {scenario} | {payment_mode} | {slab} | {amount} ---\")\n    \n        bill_amount = conv_charges = total_amount = txn_id = \"N/A\"\n        status = \"Fail\"\n    \n        try:\n            if payment_mode == \"UPI INTENT\":\n                viewport_size = {\"width\": 375, \"height\": 667}  # Example: iPhone-like dimensions\n                page_with_screenshot.set_viewport_size(viewport_size)\n                self.logger.info(\n                    f\"Set viewport size to {viewport_size['width']}x{viewport_size['height']} for UPI INTENT mode\")\n                allure.attach(page_with_screenshot.screenshot(), name=\"UPI Intent Initial Viewport\",\n                              attachment_type=allure.attachment_type.PNG)\n    \n    \n            # Initialize page objects\n            client = ClientPage(page_with_screenshot)\n            client_details = ClientDetailsPage(page_with_screenshot)\n            pg = PaymentGatewayPage(page_with_screenshot)\n            pg_response = PaymentGatewayResponsePage(page_with_screenshot)\n    \n            # Fill and verify client and payer details\n            fill_and_verify_client_details(self.logger, client, client_details, excel_client_code, excel_environment)\n            fill_payer_details(\n                self.logger, client_details, ReadConfig.get_payer_first_name(),\n                ReadConfig.get_payer_last_name(), str(amount), ReadConfig.get_payer_phone(),\n                ReadConfig.get_payer_email()\n            )\n    \n            # Get transaction ID\n            with allure.step(f\"Accessing the Client_txn_id\"):\n                txn_id = client_details.get_value(\"_client_transaction_id\")\n                allure.attach(txn_id, name=f\"Client Transaction ID for {excel_client_code}\",\n                              attachment_type=allure.attachment_type.TEXT)\n    \n            # Click Pay button\n            with allure.step(\"Clicking Pay Button\"):\n                self.logger.info(\"Clicking Pay button\")\n                client_details.click(\"_pay_btn\")\n    \n            time.sleep(5)\n    \n            # Handle payment mode and get amounts\n            bill_amount, conv_charges, total_amount = self._handle_payment_mode(pg, payment_mode, self.logger)\n    \n    \n            time.sleep(10)\n    \n    \n    \n            # # Wait for page to load and validate URL\n            # time.sleep(5)\n            # pg_response.page.wait_for_load_state(\"networkidle\")\n            # current_url = pg_response.get_current_url()\n            # self.logger.info(f\"URL after proceed to pay: {current_url}\")\n            #\n            # with allure.step(\"Validating the Base URL\"):\n            #     assert validate_base_url(current_url,\n            #                              excel_environment), f\"Base URL validation failed for {current_url}\"\n    \n            status = \"Pass\"\n    \n        except Exception as e:\n            self.logger.exception(\n                f\"Exception occurred during Cancel Transaction Test for {excel_client_code}: {str(e)}\")\n            allure.attach(str(e), name=\"Exception Details\", attachment_type=allure.attachment_type.TEXT)\n            raise\n    \n        finally:\n            # Update Excel with results\n>           update_excel_results(\n                scenario=scenario,\n                payment_mode=payment_mode,\n                slab=slab,\n                request_amount=amount,\n                actual_bill=bill_amount,\n                conv_charges=conv_charges,\n                total_amount=total_amount,\n                status=status,\n                txn_id=txn_id\n            )\n\ntestCases\\Calculation_test.py:222: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nutilites\\calculation_excel_helper.py:44: in update_excel_results\n    df.to_excel(file_path, index=False)\n.venv\\Lib\\site-packages\\pandas\\util\\_decorators.py:333: in wrapper\n    return func(*args, **kwargs)\n.venv\\Lib\\site-packages\\pandas\\core\\generic.py:2436: in to_excel\n    formatter.write(\n.venv\\Lib\\site-packages\\pandas\\io\\formats\\excel.py:943: in write\n    writer = ExcelWriter(\n.venv\\Lib\\site-packages\\pandas\\io\\excel\\_openpyxl.py:61: in __init__\n    super().__init__(\n.venv\\Lib\\site-packages\\pandas\\io\\excel\\_base.py:1246: in __init__\n    self._handles = get_handle(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npath_or_buf = 'TestData/Calculation_Testing_Report.xlsx', mode = 'wb'\n\n    @doc(compression_options=_shared_docs[\"compression_options\"] % \"path_or_buf\")\n    def get_handle(\n        path_or_buf: FilePath | BaseBuffer,\n        mode: str,\n        *,\n        encoding: str | None = None,\n        compression: CompressionOptions | None = None,\n        memory_map: bool = False,\n        is_text: bool = True,\n        errors: str | None = None,\n        storage_options: StorageOptions | None = None,\n    ) -> IOHandles[str] | IOHandles[bytes]:\n        \"\"\"\n        Get file handle for given path/buffer and mode.\n    \n        Parameters\n        ----------\n        path_or_buf : str or file handle\n            File path or object.\n        mode : str\n            Mode to open path_or_buf with.\n        encoding : str or None\n            Encoding to use.\n        {compression_options}\n    \n               May be a dict with key 'method' as compression mode\n               and other keys as compression options if compression\n               mode is 'zip'.\n    \n               Passing compression options as keys in dict is\n               supported for compression modes 'gzip', 'bz2', 'zstd' and 'zip'.\n    \n            .. versionchanged:: 1.4.0 Zstandard support.\n    \n        memory_map : bool, default False\n            See parsers._parser_params for more information. Only used by read_csv.\n        is_text : bool, default True\n            Whether the type of the content passed to the file/buffer is string or\n            bytes. This is not the same as `\"b\" not in mode`. If a string content is\n            passed to a binary file/buffer, a wrapper is inserted.\n        errors : str, default 'strict'\n            Specifies how encoding and decoding errors are to be handled.\n            See the errors argument for :func:`open` for a full list\n            of options.\n        storage_options: StorageOptions = None\n            Passed to _get_filepath_or_buffer\n    \n        Returns the dataclass IOHandles\n        \"\"\"\n        # Windows does not default to utf-8. Set to utf-8 for a consistent behavior\n        encoding = encoding or \"utf-8\"\n    \n        errors = errors or \"strict\"\n    \n        # read_csv does not know whether the buffer is opened in binary/text mode\n        if _is_binary_mode(path_or_buf, mode) and \"b\" not in mode:\n            mode += \"b\"\n    \n        # validate encoding and errors\n        codecs.lookup(encoding)\n        if isinstance(errors, str):\n            codecs.lookup_error(errors)\n    \n        # open URLs\n        ioargs = _get_filepath_or_buffer(\n            path_or_buf,\n            encoding=encoding,\n            compression=compression,\n            mode=mode,\n            storage_options=storage_options,\n        )\n    \n        handle = ioargs.filepath_or_buffer\n        handles: list[BaseBuffer]\n    \n        # memory mapping needs to be the first step\n        # only used for read_csv\n        handle, memory_map, handles = _maybe_memory_map(handle, memory_map)\n    \n        is_path = isinstance(handle, str)\n        compression_args = dict(ioargs.compression)\n        compression = compression_args.pop(\"method\")\n    \n        # Only for write methods\n        if \"r\" not in mode and is_path:\n            check_parent_directory(str(handle))\n    \n        if compression:\n            if compression != \"zstd\":\n                # compression libraries do not like an explicit text-mode\n                ioargs.mode = ioargs.mode.replace(\"t\", \"\")\n            elif compression == \"zstd\" and \"b\" not in ioargs.mode:\n                # python-zstandard defaults to text mode, but we always expect\n                # compression libraries to use binary mode.\n                ioargs.mode += \"b\"\n    \n            # GZ Compression\n            if compression == \"gzip\":\n                if isinstance(handle, str):\n                    # error: Incompatible types in assignment (expression has type\n                    # \"GzipFile\", variable has type \"Union[str, BaseBuffer]\")\n                    handle = gzip.GzipFile(  # type: ignore[assignment]\n                        filename=handle,\n                        mode=ioargs.mode,\n                        **compression_args,\n                    )\n                else:\n                    handle = gzip.GzipFile(\n                        # No overload variant of \"GzipFile\" matches argument types\n                        # \"Union[str, BaseBuffer]\", \"str\", \"Dict[str, Any]\"\n                        fileobj=handle,  # type: ignore[call-overload]\n                        mode=ioargs.mode,\n                        **compression_args,\n                    )\n    \n            # BZ Compression\n            elif compression == \"bz2\":\n                # Overload of \"BZ2File\" to handle pickle protocol 5\n                # \"Union[str, BaseBuffer]\", \"str\", \"Dict[str, Any]\"\n                handle = get_bz2_file()(  # type: ignore[call-overload]\n                    handle,\n                    mode=ioargs.mode,\n                    **compression_args,\n                )\n    \n            # ZIP Compression\n            elif compression == \"zip\":\n                # error: Argument 1 to \"_BytesZipFile\" has incompatible type\n                # \"Union[str, BaseBuffer]\"; expected \"Union[Union[str, PathLike[str]],\n                # ReadBuffer[bytes], WriteBuffer[bytes]]\"\n                handle = _BytesZipFile(\n                    handle, ioargs.mode, **compression_args  # type: ignore[arg-type]\n                )\n                if handle.buffer.mode == \"r\":\n                    handles.append(handle)\n                    zip_names = handle.buffer.namelist()\n                    if len(zip_names) == 1:\n                        handle = handle.buffer.open(zip_names.pop())\n                    elif not zip_names:\n                        raise ValueError(f\"Zero files found in ZIP file {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in ZIP file. \"\n                            f\"Only one file per ZIP: {zip_names}\"\n                        )\n    \n            # TAR Encoding\n            elif compression == \"tar\":\n                compression_args.setdefault(\"mode\", ioargs.mode)\n                if isinstance(handle, str):\n                    handle = _BytesTarFile(name=handle, **compression_args)\n                else:\n                    # error: Argument \"fileobj\" to \"_BytesTarFile\" has incompatible\n                    # type \"BaseBuffer\"; expected \"Union[ReadBuffer[bytes],\n                    # WriteBuffer[bytes], None]\"\n                    handle = _BytesTarFile(\n                        fileobj=handle, **compression_args  # type: ignore[arg-type]\n                    )\n                assert isinstance(handle, _BytesTarFile)\n                if \"r\" in handle.buffer.mode:\n                    handles.append(handle)\n                    files = handle.buffer.getnames()\n                    if len(files) == 1:\n                        file = handle.buffer.extractfile(files[0])\n                        assert file is not None\n                        handle = file\n                    elif not files:\n                        raise ValueError(f\"Zero files found in TAR archive {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in TAR archive. \"\n                            f\"Only one file per TAR archive: {files}\"\n                        )\n    \n            # XZ Compression\n            elif compression == \"xz\":\n                # error: Argument 1 to \"LZMAFile\" has incompatible type \"Union[str,\n                # BaseBuffer]\"; expected \"Optional[Union[Union[str, bytes, PathLike[str],\n                # PathLike[bytes]], IO[bytes]], None]\"\n                handle = get_lzma_file()(\n                    handle, ioargs.mode, **compression_args  # type: ignore[arg-type]\n                )\n    \n            # Zstd Compression\n            elif compression == \"zstd\":\n                zstd = import_optional_dependency(\"zstandard\")\n                if \"r\" in ioargs.mode:\n                    open_args = {\"dctx\": zstd.ZstdDecompressor(**compression_args)}\n                else:\n                    open_args = {\"cctx\": zstd.ZstdCompressor(**compression_args)}\n                handle = zstd.open(\n                    handle,\n                    mode=ioargs.mode,\n                    **open_args,\n                )\n    \n            # Unrecognized Compression\n            else:\n                msg = f\"Unrecognized compression type: {compression}\"\n                raise ValueError(msg)\n    \n            assert not isinstance(handle, str)\n            handles.append(handle)\n    \n        elif isinstance(handle, str):\n            # Check whether the filename is to be opened in binary mode.\n            # Binary mode does not support 'encoding' and 'newline'.\n            if ioargs.encoding and \"b\" not in ioargs.mode:\n                # Encoding\n                handle = open(\n                    handle,\n                    ioargs.mode,\n                    encoding=ioargs.encoding,\n                    errors=errors,\n                    newline=\"\",\n                )\n            else:\n                # Binary mode\n>               handle = open(handle, ioargs.mode)\nE               PermissionError: [Errno 13] Permission denied: 'TestData/Calculation_Testing_Report.xlsx'\n\n.venv\\Lib\\site-packages\\pandas\\io\\common.py:882: PermissionError","steps":[{"name":"Filling and verifying client details","time":{"start":1758690944826,"stop":1758690946336,"duration":1510},"status":"passed","steps":[{"name":"Filling Client Code : TM001","time":{"start":1758690944826,"stop":1758690945249,"duration":423},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"attachmentsCount":0,"attachmentStep":false,"hasContent":false,"stepsCount":0},{"name":"Selecting Environment : STAGING","time":{"start":1758690945249,"stop":1758690945645,"duration":396},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"attachmentsCount":0,"attachmentStep":false,"hasContent":false,"stepsCount":0},{"name":"Clicking Show Detail","time":{"start":1758690945645,"stop":1758690946209,"duration":564},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"attachmentsCount":0,"attachmentStep":false,"hasContent":false,"stepsCount":0},{"name":"Verifying if Payer Name is visible","time":{"start":1758690946209,"stop":1758690946336,"duration":127},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"attachmentsCount":0,"attachmentStep":false,"hasContent":false,"stepsCount":0}],"attachments":[],"parameters":[{"name":"logger","value":"<RootLogger root (DEBUG)>"},{"name":"client","value":"<pageObjects.client_page.ClientPage object at 0x000001AA3561C910>"},{"name":"client_details","value":"<pageObjects.client_details_page.ClientDetailsPage object at 0x000001AA35931590>"},{"name":"client_code","value":"'TM001'"},{"name":"environment","value":"'STAGING'"}],"shouldDisplayMessage":false,"attachmentsCount":0,"attachmentStep":false,"hasContent":true,"stepsCount":4},{"name":"Filling payer details","time":{"start":1758690946336,"stop":1758690948327,"duration":1991},"status":"passed","steps":[],"attachments":[],"parameters":[{"name":"logger","value":"<RootLogger root (DEBUG)>"},{"name":"client_details","value":"<pageObjects.client_details_page.ClientDetailsPage object at 0x000001AA35931590>"},{"name":"firstname","value":"'Bhargava'"},{"name":"lastname","value":"'Battina'"},{"name":"amount","value":"'1200'"},{"name":"mobilenumber","value":"'1234567890'"},{"name":"email","value":"'test@sabpaisa.in'"}],"shouldDisplayMessage":false,"attachmentsCount":0,"attachmentStep":false,"hasContent":true,"stepsCount":0},{"name":"Accessing the Client_txn_id","time":{"start":1758690948327,"stop":1758690948372,"duration":45},"status":"passed","steps":[],"attachments":[{"uid":"986061cd63807157","name":"Client Transaction ID for TM001","source":"986061cd63807157.txt","type":"text/plain","size":22}],"parameters":[],"shouldDisplayMessage":false,"attachmentsCount":1,"attachmentStep":false,"hasContent":true,"stepsCount":0},{"name":"Clicking Pay Button","time":{"start":1758690948372,"stop":1758690949401,"duration":1029},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"attachmentsCount":0,"attachmentStep":false,"hasContent":false,"stepsCount":0}],"attachments":[{"uid":"89510555050d0eee","name":"log","source":"89510555050d0eee.txt","type":"text/plain","size":668}],"parameters":[],"shouldDisplayMessage":true,"attachmentsCount":2,"attachmentStep":false,"hasContent":true,"stepsCount":8},"afterStages":[{"name":"ensure_db_updated::0","time":{"start":1758690969097,"stop":1758690969097,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"attachmentsCount":0,"attachmentStep":false,"hasContent":false,"stepsCount":0},{"name":"page_with_screenshot::0","time":{"start":1758690969111,"stop":1758690971925,"duration":2814},"status":"passed","steps":[],"attachments":[{"uid":"d45e78faf1ac7563","name":"Screenshot","source":"d45e78faf1ac7563.png","type":"image/png","size":14795},{"uid":"aaed7f37dca1fa71","name":"Test Video","source":"aaed7f37dca1fa71.webm","type":"video/webm","size":557316}],"parameters":[],"shouldDisplayMessage":false,"attachmentsCount":2,"attachmentStep":false,"hasContent":true,"stepsCount":0},{"name":"page::0","time":{"start":1758690971927,"stop":1758690971927,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"attachmentsCount":0,"attachmentStep":false,"hasContent":false,"stepsCount":0},{"name":"browser::0","time":{"start":1758690971930,"stop":1758690971951,"duration":21},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"attachmentsCount":0,"attachmentStep":false,"hasContent":false,"stepsCount":0}],"labels":[{"name":"story","value":"Cancel Transaction Button Check"},{"name":"severity","value":"critical"},{"name":"epic","value":"Payment Gateway"},{"name":"tag","value":"regression"},{"name":"tag","value":"ui"},{"name":"parentSuite","value":"testCases"},{"name":"suite","value":"Calculation_test"},{"name":"subSuite","value":"TestCalculations"},{"name":"host","value":"SRS-CL-009"},{"name":"thread","value":"26968-MainThread"},{"name":"framework","value":"pytest"},{"name":"language","value":"cpython3"},{"name":"package","value":"testCases.Calculation_test"},{"name":"resultFormat","value":"allure2"}],"parameters":[{"name":"amount","value":"1200"},{"name":"excel_client_code","value":"'TM001'"},{"name":"excel_environment","value":"'STAGING'"},{"name":"payment_mode","value":"'Debit Card'"},{"name":"scenario","value":"'S9'"},{"name":"slab","value":"'1001-5000'"}],"links":[],"hidden":false,"retry":false,"extra":{"severity":"critical","retries":[{"uid":"906c0317deb4bddc","status":"passed","time":{"start":1758689480373,"stop":1758689503410,"duration":23037}}],"categories":[{"name":"Test defects","matchedStatuses":[],"flaky":false}],"tags":["ui","regression"]},"source":"bcc136f5a5cfbf9b.json","parameterValues":["1200","'TM001'","'STAGING'","'Debit Card'","'S9'","'1001-5000'"]}